{"remainingRequest":"C:\\Users\\yif_z\\Desktop\\DealViewer\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\yif_z\\Desktop\\DealViewer\\src\\components\\product\\RepaymentMatrix.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\yif_z\\Desktop\\DealViewer\\src\\components\\product\\RepaymentMatrix.vue","mtime":1604281046595},{"path":"C:\\Users\\yif_z\\Desktop\\DealViewer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\yif_z\\Desktop\\DealViewer\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\yif_z\\Desktop\\DealViewer\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\yif_z\\Desktop\\DealViewer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\yif_z\\Desktop\\DealViewer\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport utilsIndex from '@/utils/index.js'\nexport default {\n  name: \"RepaymentMatrix\",\n  props: {\n    data: {\n      type: Array,\n      default: () => []\n    }\n  },\n  data() {\n    return {\n      layers: [],\n      computedLayers: [],\n      layeredInfoStyles: {\n        top: 0,\n        left: 0,\n        display: 'none'\n      },\n      layeredInfo:{\n        name: '',\n        offerAmount: '',\n        closingBalance: '',\n        closingBalanceRate:'',\n        remainingPercent: 0,\n        offerAmountPercent: 0,\n      }\n    }\n  },\n  created() {\n    this.initLayer();\n  },\n  methods: {\n    initLayer() {\n      let totalOfferAmount = 0;\n      this.data.forEach(v => {\n        console.log(v)\n        totalOfferAmount += parseFloat(v.OfferAmount);\n      });\n\n      let layers = {};\n      let layerColors = [\n        '#759ae4',\n        '#5566ce',\n        '#01d5bf',\n        '#00c673',\n        '#bfd52a',\n        '#f19603',\n        '#a36fff'\n      ];\n      this.data.forEach((v,i) => {\n        let offerAmount =  v.OfferAmount ? parseFloat(v.OfferAmount) : 0;\n        let offerAmounts =  v.OfferAmount ? utilsIndex.numUnit(v.OfferAmount) : 0;\n        let payAmount = v.PayAmount ? parseFloat(v.PayAmount) : 0;\n        let closingBalance = v.ClosingBalance ? utilsIndex.numUnit(v.ClosingBalance) : 0;\n        let closingBalanceRate = v.ClosingBalanceRate ? parseFloat(v.ClosingBalanceRate) : 0;\n        let payAmountPercent = payAmount / offerAmount * 100;\n        let offerAmountPercent = offerAmount / totalOfferAmount * 100;\n        let currentLayer = {\n          name: v.ShortName,\n          className: v.ClassName,\n          payAmountPercent: payAmountPercent,\n          payAmountStyle: {\n            height: payAmountPercent + '%',\n          },\n          offerAmountPercent: offerAmountPercent,\n          offerAmountStyle: {\n            width: '100%',\n            backgroundColor: layerColors[i]\n          },\n          text: ((v.ClassName) ? v.ClassName : '未知') + ' ' + Math.round(offerAmountPercent) + '%',\n          offerAmounts:offerAmounts,\n          closingBalance,\n          closingBalanceRate,\n          remainingPercent: (closingBalance / offerAmount),\n          value: offerAmount\n        };\n\n        if(!layers[v.ClassName]) layers[v.ClassName] = [];\n\n        layers[v.ClassName].push(currentLayer);\n\n      });\n\n      let computedLayers = [];\n\n      let freePercent = 100;\n\n      const fixedPercent = function(percent, freeCount) {\n        let o = 100 / 6;\n        if(percent <= o) {\n          freePercent -= o;\n          return o + '%';\n        }\n        if(percent === 100) return '100%';\n        let currentPercent = percent - (percent % o);\n        if( freePercent <= currentPercent ) {\n          return freePercent + '%';\n        }else{\n\n          freePercent -= currentPercent;\n          if(freeCount > 1) {\n            let needMinPercent = freeCount * o;\n            if(freePercent < needMinPercent) {\n              currentPercent =  currentPercent - (needMinPercent - freePercent);\n              freePercent = freePercent + (needMinPercent - freePercent);\n            }\n          }\n          if(freePercent > o && freeCount === 1) {\n            let needFloatPercent = freePercent - o;\n            currentPercent += needFloatPercent;\n            freePercent += needFloatPercent;\n          }\n          return currentPercent + '%';\n        }\n      };\n\n      layers = Object.values(layers);\n\n      let totalCount = layers.length;\n\n      \n\n      layers.forEach( (layer, i) => {\n        let count = layer.length;\n        let height = 0;\n        if(count > 1) {\n          let totalPercent = layer.map(v=> v.offerAmountPercent).reduce((prev, next) => prev + next);\n          layer.forEach(v => {\n            v.offerAmountStyle.width = (v.offerAmountPercent / totalPercent * 100) + '%';\n          });\n          height = totalPercent;\n        }else{\n          height = layer[0].offerAmountPercent;\n        }\n        computedLayers.push({\n          height: fixedPercent(height, totalCount - (i + 1)),\n          layer,\n          backgroundColor: layerColors[i]\n        })\n      });\n      this.computedLayers = computedLayers;\n      this.layers = layers;\n    },\n    showInfo(event, item) {\n      //console.log(e)\n      let evt = event.target;\n      let actualLeft = evt.offsetLeft + (evt.offsetWidth / 4);\n      let actualTop = evt.offsetTop + (evt.offsetHeight / 2) + 10;\n      let current = evt.offsetParent;\n      while (current !== null && current !== this.$el){\n        actualTop += current.offsetTop;\n        actualLeft += current.offsetLeft;\n        current = current.offsetParent;\n      }\n\n      if(actualLeft >= 130) {\n        actualLeft -= (this.$el.offsetWidth - 130);\n      }\n      this.layeredInfoStyles = {\n        left: actualLeft + 'px',\n        top: actualTop + 'px',\n        display: 'block'\n      };\n      this.layeredInfo = item;\n    },\n    hideInfo(event) {\n      //console.log('out', event)\n      let evt = event.toElement;\n     if(!this.$el.contains(evt)){\n       this.layeredInfoStyles.display = 'none';\n     }\n    }\n  },\n}\n",null]}